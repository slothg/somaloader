package com.soma.loader {	import flash.display.Bitmap;	import flash.display.DisplayObjectContainer;	import flash.display.Loader;	import flash.display.LoaderInfo;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.media.Sound;	import flash.media.SoundLoaderContext;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.system.ApplicationDomain;	import flash.system.Capabilities;	import flash.system.LoaderContext;	import flash.text.Font;	import flash.utils.ByteArray;	import flash.utils.Dictionary;	import flash.utils.Endian;	import flash.utils.getQualifiedClassName;		
	/** Indicates a change in the queue.     * @eventType com.soma.loader.SomaLoaderEvent.QUEUE_CHANGED */	[Event(name="QUEUE_CHANGED", type="com.soma.loader.SomaLoaderEvent.QUEUE_CHANGED")]		/** Indicates a status change in the SomaLoader instance (loading, paused, stopped).     * @eventType com.soma.loader.SomaLoaderEvent.STATUS_CHANGED */	[Event(name="STATUS_CHANGED", type="com.soma.loader.SomaLoaderEvent.STATUS_CHANGED")]		/** Indicates a change in the cache.     * @eventType com.soma.loader.SomaLoaderEvent.CACHE_CHANGED */	[Event(name="CACHE_CHANGED", type="com.soma.loader.SomaLoaderEvent.CACHE_CHANGED")]		/** Indicates an ID3 information is available when a mp3 starts to load.     * @eventType com.soma.loader.SomaLoaderEvent.ID3_COMPLETE */	[Event(name="ID3_COMPLETE", type="com.soma.loader.SomaLoaderEvent.ID3_COMPLETE")]		/** Dispatched when an error has been found in the SomaLoader instance.     * @eventType com.soma.loader.SomaLoaderEvent.ERROR */	[Event(name="ERROR", type="com.soma.loader.SomaLoaderEvent.ERROR")]		/** Dispatched when a loading of an item starts.     * @eventType com.soma.loader.SomaLoaderEvent.START */	[Event(name="START", type="com.soma.loader.SomaLoaderEvent.START")]		/** Dispatched when a loading of an item progresses.     * @eventType com.soma.loader.SomaLoaderEvent.PROGRESS */	[Event(name="PROGRESS", type="com.soma.loader.SomaLoaderEvent.PROGRESS")]		/** Dispatched when a loading of an item is complete.     * @eventType com.soma.loader.SomaLoaderEvent.COMPLETE */	[Event(name="COMPLETE", type="com.soma.loader.SomaLoaderEvent.COMPLETE")]		/** Dispatched when the loading of a list of items starts.	 * @eventType com.soma.loader.SomaLoaderEvent.QUEUE_START */	[Event(name="QUEUE_START", type="com.soma.loader.SomaLoaderEvent.QUEUE_START")]		/** Dispatched when the loading of a list of items progresses.	 * @eventType com.soma.loader.SomaLoaderEvent.QUEUE_PROGRESS */	[Event(name="QUEUE_PROGRESS", type="com.soma.loader.SomaLoaderEvent.QUEUE_PROGRESS")]		/** Dispatched when the loading of a list of items is complete.	 * @eventType com.soma.loader.SomaLoaderEvent.QUEUE_COMPLETE */	[Event(name="QUEUE_COMPLETE", type="com.soma.loader.SomaLoaderEvent.QUEUE_COMPLETE")]		/**	 * <p><b>Author:</b> Romuald Quantin - <a href="http://www.soundstep.com/" target="_blank">www.soundstep.com</a><br/>	 * <b>Project host: </b><a href="http://code.google.com/p/somaloader/" target="_blank">http://code.google.com/p/somaloader/</a><br/>	 * <b>Class version:</b> 1.0.1<br/>	 * <b>Actionscript version:</b> 3.0</p>	 * <p><b>Copyright:</b></p>	 * <p>The contents of this file are subject to the Mozilla Public License<br />	 * Version 1.1 (the "License"); you may not use this file except in compliance<br />	 * with the License. You may obtain a copy of the License at<br /></p>	 * 	 * <p><a href="http://www.mozilla.org/MPL/" target="_blank">http://www.mozilla.org/MPL/</a><br /></p>	 * 	 * <p>Software distributed under the License is distributed on an "AS IS" basis,<br />	 * WITHOUT WARRANTY OF ANY KIND, either express or implied.<br />	 * See the License for the specific language governing rights and<br />	 * limitations under the License.<br /></p>	 * 	 * <p>The Original Code is SomaLoader.<br />	 * The Initial Developer of the Original Code is Romuald Quantin.<br />	 * Initial Developer are Copyright (C) 2008-2009 Soundstep. All Rights Reserved.</p>	 * 	 * <p><b>Date:</b> 20 Feb 2009<br /></p>	 * <p><b>Usage:</b><br/>	 * SomaLoader is a lightweight loading manager written in AS3. You can load many types such as images, swf, xml, text, xml, css, fonts in a swf, mp3, variables and binary data. Items can be added, removed and changed in position from the queue even while loading.	 * SomaLoader provides a simple and unique interface for massive loading, to listen to events and access to data. SomaLoader has some specific features such as targeting before loading, easy loading progress display, caching system and binary loading for "silent loading".	 * </p>	 * @example	 * <listing version="3.0">	 * var loader:SomaLoader = new SomaLoader();	 * loader.addEventListener(SomaLoaderEvent.COMPLETE, itemComplete);	 * loader.add("photo1.jpg");	 * loader.add("photo2.jpg");	 * loader.add("photo3.jpg");	 * function itemComplete(event:SomaLoaderEvent):void {	 *     var bitmap:Bitmap = event.item.file as Bitmap;	 *     addChild(bitmap);	 * }	 * </listing>	 */		public class SomaLoader extends EventDispatcher {
		//------------------------------------		// private, protected properties		//------------------------------------				private var _queue:SomaLoaderQueue;		private var _cache:SomaLoaderCache;		private var _percentQueue:Number;		private var _loader:*;		private var _loaderContext:LoaderContext;		private var _soundLoaderContext:SoundLoaderContext;		private var _currentDispatcher:IEventDispatcher;		private var _loading:ILoading;		private var _status:String;		private var _failOnError:Boolean;		private var _showLoading:Boolean;		private var _playerVersion:int;				//------------------------------------		// public properties		//------------------------------------				/** SomaLoader version. */		public static const VERSION:String = "1.0.1";				/** Show or hide trace of internal errors. This does not affect the SomaLoaderEvent.ERROR events. */		public static var LOG_ERRORS:Boolean = true;				/** Default value for the smoothing property. When an image is loaded, this value will be set to the smoothing property of the Bitmap. */		public static var DEFAULT_BITMAP_SMOOTHING:Boolean = true;				/** Default value for the cache system, whether the cache is enable or not. This value will set the cacheEnabled property of a SomaLoaderItem when created. */		public static var DEFAULT_CACHE_ENABLED:Boolean = true;				/** Constant value used to defined the status property of the SomaLoader instance when it is loading. */		public static const STATUS_LOADING:String = "loading";				/** Constant value used to defined the status property of the SomaLoader instance when it is paused. */		public static const STATUS_PAUSED:String = "paused";				/** Constant value used to defined the status property of the SomaLoader instance when it is stopped. */		public static const STATUS_STOPPED:String = "stopped";				/** Constant value used to defined the type property of the loader for an image. */		public static const TYPE_BITMAP:String = "TypeBitmap";				/** Constant value used to defined the type property of the loader for an XML file. */		public static const TYPE_XML:String = "TypeXML";				/** Constant value used to defined the type property of the loader for an CSS file. */		public static const TYPE_CSS:String = "TypeCSS";				/** Constant value used to defined the type property of the loader for an text file. */		public static const TYPE_TEXT:String = "TypeText";				/** Constant value used to defined the type property of the loader for a SWF. */		public static const TYPE_SWF:String = "TypeSWF";				/** Constant value used to defined the type property of the loader for a MP3. */		public static const TYPE_MP3:String = "TypeMP3";				/** Constant value used to defined the type property of the loader for a SWF containing fonts. */		public static const TYPE_FONT:String = "TypeFont";				/** Constant value used to defined the type property of the loader for an unknown file. */		public static const TYPE_UNKNOWN:String = "TypeUnknown";				//------------------------------------		// constructor		//------------------------------------				/** Instantiates a SomaLoader */		public function SomaLoader() {			init();		}				//		// PRIVATE, PROTECTED		//________________________________________________________________________________________________				private function init():void {			_queue = new SomaLoaderQueue(this);			_cache = new SomaLoaderCache(this);			_status = STATUS_STOPPED;			_failOnError = false;			_showLoading = true;			_playerVersion = getFlashPlayerVersion();		}				private function getFlashPlayerVersion():int {
			var version:String = Capabilities.version;			var versionArray:Array = version.split(",");			var platformAndVersion:Array = versionArray[0].split(" ");			var majorVersion:Number = parseInt(platformAndVersion[1]);			return majorVersion;
		}				private function loadItem():void {			if (_status == STATUS_LOADING && _queue.length > 0) {				_queue.currentItem = _queue.items[0];				var useItemCache:Boolean = useCache(currentItem);				var itemCached:SomaLoaderItem = _cache.getItemByURL(currentItem.url);				if (itemCached != null) {					currentItem.setFile(itemCached.file);					currentItem.setFileBinary(itemCached.fileBinary);					currentItem.setFileFonts(itemCached.fileFonts);				}				var request:URLRequest = currentItem.request;				// cache handler				if (!currentItem.loadingFromBinary && useItemCache) {					if ((currentItem.type == TYPE_BITMAP && currentItem.dataFormat == null) || (currentItem.type == TYPE_SWF && currentItem.dataFormat == null)) {						currentItem.loadingFromBinary = true;					}					else {						openHandler();						completeHandler();						return;					}				}				if (currentItem.loadingFromBinary) {					// load from binary data					_loader = new Loader();					setListeners(Loader(_loader).contentLoaderInfo);					Loader(_loader).loadBytes(currentItem.fileBinary, _loaderContext);				}				else if ((currentItem.type == TYPE_BITMAP && currentItem.dataFormat == null) || (currentItem.type == TYPE_SWF && currentItem.dataFormat == null)) {					_loader = new Loader();					setListeners(Loader(_loader).contentLoaderInfo);					Loader(_loader).load(request, _loaderContext);				}				else if (currentItem.type == TYPE_MP3) {					// load audio file					_loader = new Sound();					setListeners(_loader);					Sound(_loader).load(request, _soundLoaderContext);				}				else if (currentItem.type == TYPE_FONT) {					// load font					_loader = new Loader();					setListeners(Loader(_loader).contentLoaderInfo);					Loader(_loader).load(request, _loaderContext);				}				else {					_loader = new URLLoader();					if (currentItem.dataFormat != null) {						URLLoader(_loader).dataFormat = currentItem.dataFormat;						if (currentItem.variables != null) URLLoader(_loader).data = currentItem.variables;					}					setListeners(_loader);					URLLoader(_loader).load(request);				}			}		}				private function useCache(item:SomaLoaderItem):Boolean {			var result:Boolean = false;			if (_playerVersion < 10) return false;			var itemCached:SomaLoaderItem = _cache.getItemByURL(item.url);			if (itemCached == null) return false;			// item found in cache			if (item.dataFormat == URLLoaderDataFormat.BINARY) {				if (itemCached.fileBinary != null) {					result = true;				}			}			else {				if (itemCached.file != undefined) {					result = true;				}			}			if (!item.cacheEnabled) result = false;			return result;		}				private function shouldCache(item:SomaLoaderItem):Boolean {			return item.cacheEnabled;		}		private function setListeners(dispatcher:IEventDispatcher):void {			_currentDispatcher = dispatcher;            dispatcher.addEventListener(Event.OPEN, openHandler, false, 0, true);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler, false, 0, true);            dispatcher.addEventListener(Event.COMPLETE, completeHandler, false, 0, true);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false, 0, true);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler, false, 0, true);            dispatcher.addEventListener(Event.ID3, ID3Handler, false, 0, true);          }				private function removeListeners():void {            _currentDispatcher.removeEventListener(Event.OPEN, openHandler, false);            _currentDispatcher.removeEventListener(ProgressEvent.PROGRESS, progressHandler, false);            _currentDispatcher.removeEventListener(Event.COMPLETE, completeHandler, false);            _currentDispatcher.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false);            _currentDispatcher.removeEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler, false);            _currentDispatcher.removeEventListener(Event.ID3, ID3Handler, false);          }		        private function openHandler(e:Event = null):void {			var event:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.START);			event.loader = this;			event.item = currentItem;			event.count = _queue.count;			event.length = _queue.length;			event.loading = _loading;			dispatchEvent(event);			// loading			if (_loading != null && _showLoading) _loading.itemStart(event);        }        private function progressHandler(e:ProgressEvent):void {			_percentQueue = (e.bytesLoaded * 100 / e.bytesTotal) / _queue.numItems + (_queue.count * 100 / _queue.numItems);			var percentItem:Number = e.bytesLoaded * 100 / e.bytesTotal;			// item event            var eventItem:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.PROGRESS);			eventItem.loader = this;			eventItem.item = currentItem;			eventItem.count = _queue.count;			eventItem.length = _queue.length;			eventItem.loading = _loading;			eventItem.percentItem = percentItem;			eventItem.percentQueue = _percentQueue;			eventItem.bytesLoaded = e.bytesLoaded;			eventItem.bytesTotal = e.bytesTotal;			dispatchEvent(eventItem);			// queue event            var eventQueue:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.QUEUE_PROGRESS);			eventQueue.loader = this;			eventQueue.item = currentItem;			eventQueue.count = _queue.count;			eventQueue.length = _queue.length;			eventQueue.loading = _loading;			eventQueue.percentQueue = _percentQueue;			dispatchEvent(eventQueue);			// loading			if (_loading != null && _showLoading) {				_loading.itemProgress(eventItem);				_loading.queueProgress(eventQueue);			}		}		private function completeHandler(e:Event = null):void {			processFile(e);			cacheItem();			currentItem.applyFileProperties();			currentItem.applyContainerProperties();            _queue.items.splice(0, 1);            if (_queue.length == 0) setStatus(STATUS_STOPPED);			var event:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.COMPLETE);			event.loader = this;			event.item = currentItem;			event.count = _queue.count;			event.length = _queue.length;			event.loading = _loading;			dispatchEvent(event);            clearLoader();			// loading			if (_loading != null && _showLoading) _loading.itemComplete(event);            _queue.count++;            if (_queue.length > 0) {            	loadItem();            }            else {            	var eventEnd:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.QUEUE_COMPLETE);            	eventEnd.loader = this;				eventEnd.item = currentItem;				eventEnd.count = _queue.count;				eventEnd.length = _queue.length;				eventEnd.loading = _loading;				eventEnd.percentQueue = _percentQueue;				dispatchEvent(eventEnd);            	clear();            	if (_loading != null && _showLoading) _loading.queueComplete();            }        }                private function ID3Handler(e:Event):void {        	var eventEnd:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.ID3_COMPLETE);			eventEnd.loader = this;			eventEnd.item = currentItem;			eventEnd.count = _queue.count;			eventEnd.length = _queue.length;			eventEnd.loading = _loading;			eventEnd.id3Info = e.target['id3'];			dispatchEvent(eventEnd);        }        private function securityErrorHandler(e:SecurityErrorEvent):void {        	var event:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.ERROR);			event.errorMessage = "Error in [SomaLoader] SecurityError: " + e.text;			event.loader = this;			event.item = currentItem;			event.count = _queue.count;			event.length = _queue.length;			event.loading = _loading;			dispatchEvent(event);			if (_loading != null && _showLoading) _loading.error(event);			if (!_failOnError) {				 _queue.items.splice(0, 1);				 _queue.count++;	            clearLoader();	            if (_queue.length > 0) {	            	loadItem();	            }			}			else setStatus(SomaLoader.STATUS_STOPPED);		}		private function ioErrorHandler(e:IOErrorEvent):void {        	var event:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.ERROR);			event.errorMessage = "Error in [SomaLoader] IOErrorEvent: " + e.text;			event.loader = this;			event.item = currentItem;			event.count = _queue.count;			event.length = _queue.length;			event.loading = _loading;			dispatchEvent(event);			if (_loading != null && _showLoading) _loading.error(event);			if (!_failOnError) {				 _queue.items.splice(0, 1);				 _queue.count++;	            clearLoader();	            if (_queue.length > 0) {	            	loadItem();	            }			}			else setStatus(SomaLoader.STATUS_STOPPED);        }                private function cacheItem():void {
			if (shouldCache(currentItem)) {				_cache.add(currentItem);				var eventCache:SomaLoaderEvent = new SomaLoaderEvent(SomaLoaderEvent.CACHE_CHANGED);				eventCache.loader = this;				eventCache.item = currentItem;				dispatchEvent(eventCache);			}
		}				private function processFile(e:Event = null):void {			if (e != null) {				// file not cached				if (currentItem.type == TYPE_BITMAP && _loader is Loader) {					// a object created with a Loader.loadBytes and with the bytes of a Loader (LoaderInfo(e.target).bytes) seems to always be a MovieClip					// To keep the right file, I extract the Bitmap from the MovieClip created					var file:Bitmap = (LoaderInfo(e.target).content is MovieClip) ? MovieClip(LoaderInfo(e.target).content).getChildAt(0) as Bitmap : LoaderInfo(e.target).content as Bitmap;					currentItem.setFile(file);					if (_playerVersion >= 10) currentItem.setFileBinary(LoaderInfo(e.target)['bytes']);					if (currentItem.container != null) {						currentItem.container.addChild(currentItem.file);					}					if (currentItem.fileProperties["smoothing"] == undefined && DEFAULT_BITMAP_SMOOTHING) {						currentItem.addFileProperty("smoothing", true);					}				}				else if (currentItem.type == TYPE_SWF && _loader is Loader) {					currentItem.setFile(LoaderInfo(e.target).content);					if (_playerVersion >= 10) currentItem.setFileBinary(LoaderInfo(e.target)['bytes']);					if (currentItem.container != null) {						currentItem.container.addChild(currentItem.file);					}				}				else if (currentItem.type == TYPE_MP3) {					currentItem.setFile(e.target);				}				else if (currentItem.type == TYPE_FONT) {					currentItem.setFile(LoaderInfo(e.target).content);					processFonts();				}				else {					if (currentItem.dataFormat == URLLoaderDataFormat.BINARY) {						currentItem.setFileBinary(URLLoader(e.target).data);					}					else {						currentItem.setFile(URLLoader(e.target).data);					}				}			}			else {				// file cached				if (currentItem.type == TYPE_BITMAP && currentItem.dataFormat == null) {					if (currentItem.container != null) {						currentItem.container.addChild(currentItem.file);					}					if (currentItem.fileProperties["smoothing"] == undefined && DEFAULT_BITMAP_SMOOTHING) {						currentItem.addFileProperty("smoothing", true);					}				}				else if (currentItem.type == TYPE_SWF && currentItem.dataFormat == null) {					if (currentItem.container != null) {						currentItem.container.addChild(currentItem.file);					}				}			}		}						private function processFonts():void {			try {				var domain:ApplicationDomain = Loader(_loader).contentLoaderInfo.applicationDomain;				var getFontClass:Function = function(element:String, index:int, array:Array):Font {					var fonts:Array = Font.enumerateFonts();					var length:Number = fonts.length;					for (var i:int = 0; i<length; i++) {						if (getQualifiedClassName(fonts[i]) == element) {							return fonts[i] as Font;						}					}					return null;					index; array;				};				var fontNames:Array;				if (currentItem.fontNames != null && currentItem.fontNames.length > 0) fontNames = currentItem.fontNames;				else if (_playerVersion >= 10) fontNames = getClasses(MovieClip(currentItem.file).loaderInfo['bytes']);				else return;				for (var j:int = 0; j<fontNames.length; j++) {					var FontClass:Class = domain.getDefinition(fontNames[j]) as Class;					Font.registerFont(FontClass);				}				// register font loaded				currentItem.setFileFonts(fontNames.map(getFontClass));			} catch (e:Error) {				if (SomaLoader.LOG_ERRORS) {					trace("Error in [SomaLoader]: unable to process the fonts in: " + currentItem.url);					trace(e);				}			}		}				private function getClasses(stream:ByteArray):Array {			var filter:Function = function (element:TagInfos, index:int, array:Array):Boolean {				return element.tag == 0x4C;				index; array;			};			var arrayClasses:Array = new Array();			stream.position = 0;			var compressed:uint = stream.readUnsignedByte();			stream.position += 2;			stream.readByte();			stream.endian = Endian.LITTLE_ENDIAN;			stream.readUnsignedInt();			var swf:ByteArray = new ByteArray();			stream.readBytes(swf,0);			if (compressed == 0x43) swf.uncompress();			swf.endian = Endian.LITTLE_ENDIAN;			var nBits:Number = (((swf.readByte()>>3)*4-3)>>3)+1;			swf.position += nBits+1;			swf.readByte();			swf.readShort();			var dictionary:Array = browseTables(swf);			var symbolClasses:Array = dictionary.filter(filter);			var i:int;			var count:int;			var char:int;			var name:String;			if (symbolClasses.length) {				swf.position = symbolClasses[0].offset;				count = swf.readUnsignedShort();				for (i = 0; i< count; i++) {					swf.readUnsignedShort();					char = swf.readByte();					name = new String();		            while (char != 0) {		                name += String.fromCharCode(char);		                char = swf.readByte();		            }					arrayClasses.push(name);				}			}			return arrayClasses;		}				private function browseTables(swf:ByteArray):Array {			var currentTag:int;			var step:int;			var dictionary:Array = new Array();			var infos:TagInfos;			while (currentTag = ((swf.readShort() >> 6) & 0x3FF)) {				infos = new TagInfos();				infos.tag = currentTag; 				infos.offset = swf.position;				swf.position -= 2;				step = swf.readShort() & 0x3F;				if (step < 0x3F) {					swf.position += step;				}				else {					step = swf.readUnsignedInt();					infos.offset = swf.position;					swf.position += step;				}				infos.endOffset = swf.position;						dictionary.push ( infos );			}			return dictionary;		}		private function clear():void {			var numItemsInQueue:int = _queue.length;			_queue.reset();			_percentQueue = 0;			clearLoader();			if (_status != STATUS_STOPPED) setStatus(STATUS_STOPPED);			if (numItemsInQueue > 0) dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));		}				private function clearLoader():void {			removeListeners();			if (_loader != null) {				try {					_loader['close']();					_loader['unload']();				} catch (e:Error) {				} finally {					_loader = null;				}			}		}				private function setStatus(status:String):void {			_status = status;			dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.STATUS_CHANGED));		}				// PUBLIC		//________________________________________________________________________________________________				/** starts the loading of the items in the queue. The queue must contains at least one item. */		public function start():void {			if (_status == STATUS_PAUSED) {				resume();				return;			}			if (_status == STATUS_STOPPED && _queue.length > 0) {				setStatus(STATUS_LOADING);				_percentQueue = 0;				_queue.count = 0;				_queue.currentItem = null;				_queue.numItems = _queue.length;				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_START));				if (_loading != null && _showLoading) _loading.queueStart();				loadItem();			}		}				/** stops the loading and reset the queue. */		public function stop():void {			if (_status == STATUS_LOADING || _status == STATUS_PAUSED) {				clear();				if (_loading != null && _showLoading) _loading.queueComplete();				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_COMPLETE));			}		}		/** stops the loading and keep the items not loaded in the queue, the loading can be resumed. */		public function pause():void {			if (_status == STATUS_LOADING) {				setStatus(STATUS_PAUSED);				clearLoader();			}		}		/** resume a loading that has been paused. */		public function resume():void {			if (_status == STATUS_PAUSED && _queue.length > 0) {				setStatus(STATUS_LOADING);				loadItem();			}		}				/** add an item at the end of the queue.		 * @param url URL of the object to load.		 * @param container DisplayObjectContainer instance, if set and if possible, the file loaded will be added to the display list of this container.		 * @param type Type of the file that will be loaded. SomaLoader can find the proper type with the extension of the file, but it can be set manually (type example: SomaLoader.TYPE_BITMAP).		 * @param data custom Object that can contain anything.		 * @param dataFormat URLLoaderDataFormat for a URLLoader instance. The default is URLLoaderDataFormat.TEXT and can also be URLLoaderDataFormat.BINARY and URLLoaderDataFormat.VARIABLES.		 * @return an instance of SomaLoaderItem if it has been successfully added to the queue.		 */		public function add(url:String, container:DisplayObjectContainer = null, type:String = null, data:* = null, dataFormat:String = null):SomaLoaderItem {			var item:SomaLoaderItem = _queue.add(url, container, type, data, dataFormat);			if (item != null) {				item.cacheEnabled = DEFAULT_CACHE_ENABLED;				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return item;		}				/** add an item to a specific index in the queue. The index 0 can't be used if the SomaLoader instance is currently loading.		 * @param url URL of the object to load.		 * @param index position of the item in the queue.		 * @param container DisplayObjectContainer instance, if set and if possible, the file loaded will be added to the display list of this container.		 * @param type Type of the file that will be loaded. SomaLoader can find the proper type with the extension of the file, but it can be set manually (type example: SomaLoader.TYPE_BITMAP).		 * @param data custom Object that can contain anything.		 * @param dataFormat URLLoaderDataFormat for a URLLoader instance. The default is URLLoaderDataFormat.TEXT and can also be URLLoaderDataFormat.BINARY and URLLoaderDataFormat.VARIABLES.		 * @return an instance of SomaLoaderItem if it has been successfully added to the queue.		 */		public function addAt(url:String, index:int, container:DisplayObjectContainer = null, type:String = null, data:* = null, dataFormat:String = null):SomaLoaderItem {			var item:SomaLoaderItem = _queue.addAt(url, index, container, type, data, dataFormat);			if (item != null) {				item.cacheEnabled = DEFAULT_CACHE_ENABLED;				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return item;		}				/** add a SomaLoaderItem instance in the queue that contains Binary data (item.fileBinary), to create an instance of Bitmap or MovieClip.		 * @param item SomaLoaderItem that contains Binary data.		 * @param container DisplayObjectContainer instance, if set and if possible, the file loaded will be added to the display list of this container.		 * @param data custom Object that can contain anything.		 * @return the instance of the SomaLoaderItem if it has been successfully added to the queue.		 */		public function addBinary(item:SomaLoaderItem, container:DisplayObjectContainer = null, data:* = null):SomaLoaderItem {			var itemBinary:SomaLoaderItem = _queue.addBinary(item, container, data);			if (itemBinary != null) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return itemBinary;		}				/** add a SomaLoaderItem instance that contains Binary data (item.fileBinary) to a specific index, to create an instance of Bitmap or MovieClip. The index 0 can't be used if the SomaLoader instance is currently loading. 		 * @param item SomaLoaderItem that contains Binary data.		 * @param index position of the item in the queue.		 * @param container DisplayObjectContainer instance, if set and if possible, the file loaded will be added to the display list of this container.		 * @param data custom Object that can contain anything.		 * @return the instance of the SomaLoaderItem if it has been successfully added to the queue.		 */		public function addBinaryAt(item:SomaLoaderItem, index:int, container:DisplayObjectContainer = null, data:* = null):SomaLoaderItem {			var itemBinary:SomaLoaderItem = _queue.addBinaryAt(item, index, container, data);			if (itemBinary != null) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return itemBinary;		}				/** find an item with the URL and remove it from the queue.		 * @param url URL of the object to remove.		 * @return a Boolean indicating if it has been successfully removed.		 */		public function remove(url:String):Boolean {			var result:Boolean = _queue.remove(url);			if (result) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return result;		}				/** find an item with the index and remove it from the queue. The index 0 can't be used if the SomaLoader instance is currently loading.		 * @param index position of the item in the queue.		 * @return a Boolean indicating if it has been successfully removed.		 */		public function removeAt(index:int):Boolean {			var result:Boolean = _queue.removeAt(index);			if (result) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return result;		}				/** remove all the item from the queue. If the SomaLoader instance is currently loading, the item at the index 0 will not be removed.		 * @return a Boolean indicating if the process has been successful.		 */		public function removeAll():Boolean {			var result:Boolean = _queue.removeAll();			if (result) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.QUEUE_CHANGED));			}			return result;		}				/** stop and dispose the SomaLoader instance to remove listeners and delete built-in loaders. 		 * @param cacheIncluded Whether or not the cache of the SomaLoader instance should be cleared in the same time.		 */		public function dispose(cacheIncluded:Boolean = false):void {			try {				if (_status == STATUS_LOADING) stop();				else clear();				if (cacheIncluded) {					clearCache();				}			} catch (e:Error) {}		}				/** Indicates if the queue contains an item with a URL.		 * @param url URL of the item.		 * @return a Boolean.		 */		public function contains(url:String):Boolean {			return _queue.contains(url);		}				/** get an item in the queue with the URL		 * @param url URL of the item.		 * @return the SomaLoaderItem instance that has been found.		 */		public function getItem(url:String):SomaLoaderItem {			return _queue.getItem(url);		}				/** get an item in the queue at the specified index		 * @param index position of the item in the queue.		 * @return the SomaLoaderItem instance that has been found.		 */		public function getItemAt(index:int):SomaLoaderItem {			return _queue.getItemAt(index);		}				/** get the last item added in the queue.		 * @return the SomaLoaderItem instance that has been found.		 */		public function getLastItem():SomaLoaderItem {			return _queue.getLastItem();		}		/** get the item position in the queue with the url of this item.		 * @param url URL of the item.		 * @return the position of the item.		 */		public function getIndex(url:String):int {			return _queue.getIndex(url);		}				/** set the item position in the queue with the url of this item.		 * @param url URL of the item.		 * @param index position of the item in the queue.		 * @return a Boolean indicating if the process has been successful.		 */		public function setIndex(url:String, index:int):Boolean {			return _queue.setIndex(url, index);		}				/** get the length of the queue (number of items in the queue).		 * @return a Int.		 */		public function get length():int {			return _queue.length;		}				/** get the length of the cache (number of items cached).		 * @return a Int.		 */		public function get lengthCache():int {			return _cache.length;		}				/** get a copy of the list of items in the queue.		 * @return an Array of SomaLoaderItem instances.		 */		public function get items():Array {			return _queue.items.concat();		}				/** Returns a String describing the SomaLoader instance.		 * @return a String.		 */		public function info():String {			var str:String = "[SomaLoader]\n";			var length:int = _queue.length;			for (var i:int=0; i<length; i++) {				str += _queue.items[i] + "\n";			}			str += "status: " + _status + "\n";			str += "length: " + length + "\n";			str += "cache length: " + lengthCache + "\n";			str += "current item: " + currentItem + "\n";			str += "current loader: " + currentLoader + "\n";			str += "fail on error: " + failOnError + "\n";			str += "show loading: " + showLoading;			return str;		}				/** LoaderContext used in the SomaLoader instance.  */		public function get loaderContext():LoaderContext {			return _loaderContext;		}				public function set loaderContext(value:LoaderContext):void {			_loaderContext = value;		}				/** ILoading instance used to display a loading progress.  */		public function get loading():ILoading {			return _loading;		}				public function set loading(loading:ILoading):void {			_loading = loading;		}				/** get the loading status of the SomaLoader instance, can be SomaLoader.STATUS_LOADING, SomaLoader.STATUS_PAUSED or SomaLoader.STATUS_STOPPED. */		public function get status():String {			return _status;		}				/** get the list of the SomaLoaderItem instances stored in the cache.		 * @return a Dictionary.		 */		public function getLoadedItems():Dictionary {			return _cache.getItems();		}				/** get a SomaLoaderItem instance stored in the cache with the URL.		 * @param url URL of the SomaLoader instance		 * @return a SomaLoaderItem.		 */		public function getLoadedItemByURL(url:String):SomaLoaderItem {			return _cache.getItemByURL(url);		}				/** get a SomaLoaderItem instance stored in the cache with a key and a value of an Object set to the data property of a SomaLoaderItem instance.		 * <listing version="3.0">		 * loader.add("photo1.jpg", null, null, {myKey:"myValue"});		 * // or		 * var item:SomaLoaderItem = loader.add("photo1.jpg");		 * item.data = {myKey:"myValue"};		 * ...		 * var item:SomaLoaderItem = loader.getLoadedItemByOwnKey("myKey", "myValue");		 * </listing>		 * @param key property of an custom Object.		 * @param key value of the property of an custom Object.		 * @return a SomaLoaderItem.		 */		public function getLoadedItemByOwnKey(key:String, value:*):SomaLoaderItem {			return _cache.getItemByOwnKey(key, value);		}				/** get the list of the SomaLoaderItem instances stored in the cache containing a ByteArray set to the fileBinary property of the SomaLoaderItem instance.		 * @param type The type of the SomaLoaderItem can be specified to filter the search.		 * @return an Array.		 */		public function getBinaryLoadedItems(type:String = null):Array {			return _cache.getBinaryLoadedItems(type);		}				/** get a SomaLoaderItem instance stored in the cache containing a ByteArray set to the fileBinary property of the SomaLoaderItem instance with the URL.		 * @param url URL of the SomaLoader instance		 * @return a SomaLoaderItem.		 */		public function getBinaryLoadedItemByURL(url:String):SomaLoaderItem {			return _cache.getBinaryLoadedItemByURL(url);		}				/** get a SomaLoaderItem instance stored in the cache with a key and a value of an Object set to the data property of a SomaLoaderItem instance.		 * <listing version="3.0">		 * loader.add("photo1.jpg", null, null, {myKey:"myValue"}, URLLoaderDataFormat.BINARY);		 * // or		 * var item:SomaLoaderItem = loader.add("photo1.jpg");		 * item.dataFormat = URLLoaderDataFormat.BINARY;		 * item.data = {myKey:"myValue"};		 * ...		 * var itemBinary:SomaLoaderItem = loader.getBinaryLoadedItemByOwnKey("myKey", "myValue");		 * </listing>		 * @param key property of an custom Object.		 * @param key value of the property of an custom Object.		 * @return a SomaLoaderItem.		 */		public function getBinaryLoadedItemByOwnKey(key:String, value:*):SomaLoaderItem {			return _cache.getBinaryLoadedItemByOwnKey(key, value);		}				/** remove a SomaLoaderItem instance stored in the cache.		 * @param item SomaLoaderItem instance to remove.		 * @return a Boolean indicating that the item has been successfully removed.		 */		public function removeItemLoaded(item:SomaLoaderItem):Boolean {			var result:Boolean = _cache.removeByURL(item.url);			if (result) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.CACHE_CHANGED));			}			return result;		}				/** remove a SomaLoaderItem instance stored in the cache with the URL.		 * @param url URL of the SomaLoaderItem instance to remove.		 * @return a Boolean indicating that the item has been successfully removed.		 */		public function removeItemLoadedByURL(url:String):Boolean {			var result:Boolean = _cache.removeByURL(url);			if (result) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.CACHE_CHANGED));			}			return result;		}				/** remove a SomaLoaderItem instance stored in the cache with a key and a value of an Object set to the data property of a SomaLoaderItem instance.		 * <listing version="3.0">		 * loader.add("photo1.jpg", null, null, {myKey:"myValue"}, URLLoaderDataFormat.BINARY);		 * // or		 * var item:SomaLoaderItem = loader.add("photo1.jpg");		 * item.dataFormat = URLLoaderDataFormat.BINARY;		 * item.data = {myKey:"myValue"};		 * // if the item has been loaded:		 * var item:SomaLoaderItem = loader.removeItemLoadedByOwnKey("myKey", "myValue");		 * </listing>		 * @param key property of an custom Object.		 * @param key value of the property of an custom Object.		 * @return a SomaLoaderItem.		 */		public function removeItemLoadedByOwnKey(key:String, value:*):Boolean {			var result:Boolean = _cache.removeByOwnKey(key, value);			if (result) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.CACHE_CHANGED));			}			return result;		}				/** clear the cache (remove all the SomaLoaderItem instance loaded). */		public function clearCache():void {			var cacheLength:int = _cache.length;			_cache.dispose();			if (cacheLength > 0) {				dispatchEvent(new SomaLoaderEvent(SomaLoaderEvent.CACHE_CHANGED));			}		}				/** get the current built-in loader instance used in SomaLoader, can be Loader, URLLoader or Sound.		 * @return a built-in loader instance.		 */		public function get currentLoader():* {			if (_loader is Loader) return _loader as Loader;			else if (_loader is URLLoader) return _loader as URLLoader;			else if (_loader is Sound) return _loader as Sound;			else return null;		}				/** SoundLoaderContext used in the SomaLoader instance.  */		public function get soundLoaderContext():SoundLoaderContext {			return _soundLoaderContext;		}				public function set soundLoaderContext(value:SoundLoaderContext):void {			_soundLoaderContext = value;		}				/** indicates if the loading of the items in the queue should stop or continue if an error is found, the default is false. */		public function get failOnError():Boolean {			return _failOnError;		}				public function set failOnError(value:Boolean):void {			_failOnError = value;		}				/** get the item that is currently loading.		 * @return a SomaLoaderItem instance.		 */		public function get currentItem():SomaLoaderItem {			return _queue.currentItem;		}				/** indicates if the ILoading instance should be used to display the progress. */		public function get showLoading():Boolean {			return _showLoading;		}				public function set showLoading(value:Boolean):void {			_showLoading = value;		}				/** get the major version of the user's Flash Player.		 * @return the Flash Player version.		 */		public function get playerVersion():int {			return _playerVersion;		}			}}/** @private */final class TagInfos {	public var offset:int;	public var endOffset:int;	public var tag:int;	}